#include "game.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/gatech.h"
#include "images/background.h"
#include "images/winbg.h"
#include "images/losebg.h"



/* TODO: */
// Add any additional states you need for your app.
typedef enum {
  START_BG,
  START,
  START_SET_UP_DEFAULT,
  START_SET_UP_CHANGE,
  PLAY_INFO,
  PLAY,
  WIN_BG,
  WON,
  LOSE_BG,
  LOST,
} GBAState;

void initUnit(struct state *cs, int r, int c, volatile u16 core_color, volatile u16 in_color, volatile u16 out_color) {
  // Initialize unit
  cs->size = 10;
  cs->unit.core.row = r;
  cs->unit.core.col = c;
  cs->unit.core.color = core_color;
  
  // LEFT
  cs->unit.adj[0].col = cs->unit.core.col - ADJ_CLOSE - (cs->size - 2);
  cs->unit.adj[0].row = cs->unit.core.row + 1;
  cs->unit.adj[0].color = in_color;
  
  cs->unit.adj[1].col = cs->unit.core.col - ADJ_CLOSE - (cs->size - 2) - ADJ_FAR - (cs->size - 4);
  cs->unit.adj[1].row = cs->unit.core.row + 2;
  cs->unit.adj[1].color = out_color;
  
  // UP
  cs->unit.adj[2].col = cs->unit.core.col + 1;
  cs->unit.adj[2].row = cs->unit.core.row - ADJ_CLOSE - (cs->size - 2);
  cs->unit.adj[2].color = in_color;
  
  cs->unit.adj[3].col = cs->unit.core.col + 2;
  cs->unit.adj[3].row = cs->unit.core.row - ADJ_CLOSE - (cs->size - 2) - ADJ_FAR - (cs->size - 4);
  cs->unit.adj[3].color = out_color;
  
  // RIGHT
  cs->unit.adj[4].col = cs->unit.core.col + cs->size + ADJ_CLOSE;
  cs->unit.adj[4].row = cs->unit.core.row + 1;
  cs->unit.adj[4].color = in_color;
  
  cs->unit.adj[5].col = cs->unit.core.col + cs->size + ADJ_CLOSE + (cs->size - 2) + ADJ_FAR;
  cs->unit.adj[5].row = cs->unit.core.row + 2;
  cs->unit.adj[5].color = out_color;

  //DOWN
  cs->unit.adj[6].col = cs->unit.core.col + 1;
  cs->unit.adj[6].row = cs->unit.core.row + cs->size + ADJ_CLOSE;
  cs->unit.adj[6].color = in_color;
  
  cs->unit.adj[7].col = cs->unit.core.col + 2;
  cs->unit.adj[7].row = cs->unit.core.row + cs->size + ADJ_CLOSE + (cs->size - 2) + ADJ_FAR;
  cs->unit.adj[7].color = out_color;
}

void drawUnit(struct state state, volatile u16 core_color, volatile u16 in_color, volatile u16 out_color) {
  delay(4);
  drawRectDMA(state.unit.core.row, state.unit.core.col, state.size, state.size, core_color);

  delay(4);
  for (int i = 0; i < 8; i += 2) {
    drawRectDMA(state.unit.adj[i].row, state.unit.adj[i].col, state.size - 2, state.size - 2, in_color);
  }

  delay(4);
  for (int i = 1; i < 8; i += 2) {
    drawRectDMA(state.unit.adj[i].row, state.unit.adj[i].col, state.size - 4, state.size - 4, out_color);
  }
}

int mod(int x, int a) {
  if ((x + a > 6) || (x + a < 0)) {
    return (x+a) % 5;
  } else {
    return x+a;
  }
}

int isCollide(struct square x, struct square y, int xs, int ys) {
  if ((x.row <= y.row) && (x.row + xs <= y.row)) {
    return 1;
  }
  if ((x.col <= y.col) && (x.col + xs < y.col)) {
    return 1;
  }
  if ((x.row <= (y.row + ys)) && (x.row + xs < (y.row + ys))) {
    return 1;
  }
  if ((x.col >= y.col) && (x.col >(y.col + ys))) {
    return 1;
  } 
  return 0; 
}
int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial game state
  GBAState state = START_BG;
  
  // Color group to change
  u16 colors[][3] = {
    {WHITE, WHITE_GRAY, M_GRAY},
    {RED, RED_1, RED_2},
    {MAGENTA, MAGENTA_1, MAGENTA_2},
    {GREEN, GREEN_1, GREEN_2},
    {CYAN, CYAN_1, CYAN_2},
    {BLUE, BLUE_1, BLUE_2}
  };

  int colorIndex = 0;
  int score = 0;
  int randON = 0;
  int randGN = 0;

  struct square obs[5];
  struct square goals[10];

  // GAME LOOP
  while (1) {
    currentButtons = BUTTONS;  // Load the current state of the buttons
    
    char welcome[] = "PRESS START TO START";
    char buffer[] = "Score: ";
    char win[] = "YOU WON!\nPlay again?";
    char lose[] = "PRESS SELECT TO RESTART";
    char sc = '0';
    ps = cs;
    
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    switch (state) {
      waitForVBlank();
      case START_BG:
        score = 0;
        colorIndex = 0;

        drawImageDMA(0,0, BACKGROUND_WIDTH, BACKGROUND_HEIGHT, background);
        state = START;
        break;

      case START:
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          // Erase 
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, welcome, BLACK);
          state = START_SET_UP_DEFAULT;
          break;
        } else {
          // Blinking Text
          delay(7);
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, welcome, WHITE_GRAY);
          delay(7);
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, welcome, M_GRAY);
          delay(7);
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, welcome, BLACK);
          delay(7);
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, welcome, M_GRAY);
        }
             
        break;

      case START_SET_UP_DEFAULT:;
        fillScreenDMA(BLACK);
        // Info string display
        char press_R[] = ">";;
        char press_L[] = "<";
        char info_1[] = "Press L or R to change color";
        char info_2[] = "Press START to start";
        
        drawCenteredString(HEIGHT/2, 10, 0,0, press_L, WHITE_GRAY);
        drawCenteredString(10, WIDTH/2, 0,0, info_1, WHITE);
        drawCenteredString(HEIGHT -10, WIDTH/2, 0,0, info_2, WHITE);
        drawCenteredString(HEIGHT/2, -10, 0,0, press_R, WHITE_GRAY);
        // 
        
        // Draw unit with Default color(WHITE, WHITE_GRAY, M_GRAY)
        initUnit(&cs, (HEIGHT/2) - (cs.size/2), (WIDTH/2) - (cs.size/2), colors[colorIndex][0], colors[colorIndex][1], colors[colorIndex][2]);
        drawUnit(cs, colors[colorIndex][0], colors[colorIndex][1], colors[colorIndex][2]);
        //
        state = START_SET_UP_CHANGE;
      break;

      case START_SET_UP_CHANGE:
        ps = cs;

        if (KEY_JUST_PRESSED(BUTTON_R, currentButtons, previousButtons)) {
          // Erase previous Unit
          drawUnit(ps, BLACK, BLACK, BLACK);
          //
          colorIndex = mod(colorIndex, 1);
          // Change color
          drawUnit(cs, colors[colorIndex][0], colors[colorIndex][1], colors[colorIndex][2]);
          //
          
        }
        if (KEY_JUST_PRESSED(BUTTON_L, currentButtons, previousButtons)) {
          // Erase previous Unit
          drawUnit(ps, BLACK, BLACK, BLACK);
          //
          colorIndex = mod(colorIndex, -1);
          // Change color
          drawUnit(cs, colors[colorIndex][0], colors[colorIndex][1], colors[colorIndex][2]);
          //
        }

        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          // Erase text
          drawRectDMA(HEIGHT/2 -5, 5, 20,20, BLACK);
          drawCenteredString(10, WIDTH/2, 0,0, info_1, BLACK);
          drawCenteredString(HEIGHT -10, WIDTH/2, 0,0, info_2, BLACK);
          drawRectDMA(HEIGHT/2 -5, WIDTH-20, 20,20, BLACK);
          //
          state = PLAY_INFO;
        }
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START_BG;
        }

        break;

      case PLAY_INFO:
        sc += score;

        drawString(HEIGHT-15, 5, buffer, CYAN_1);

        int randCol = 0;
        int randRow = 0;
        randON = randint(2, 5);;

        // Obstacle objs
        for (int i = 0; i < randON; i++) {
          randCol = randint(10, WIDTH/2 - 40);
          randRow = randint(10, HEIGHT/2 - 40);

          obs[i].col = randCol;
          obs[i].row = randRow;
          obs[i].color = colors[mod(colorIndex, 2)][0];
          drawRectDMA(obs[i].col, obs[i].row, cs.size - 4, cs.size - 4, obs[i].color);
        }

        randGN = randint(5, 10);
        // Goal objs
        for (int i = 0; i < randGN; i++) {
          randCol = randint(10, WIDTH/2 - 40);
          randRow = randint(10, HEIGHT/2 - 40);

          goals[i].col = randCol + obs[i].col;
          goals[i].row = randRow + obs[i].row;
          goals[i].color = colors[colorIndex][1];
          drawRectDMA(goals[i].col, goals[i].row, cs.size - 6, cs.size - 6, goals[i].color);
        }

        state = PLAY;
        break;

      case PLAY:
        // Display Score
        drawChar(HEIGHT-15, 45, sc, RED_1);

        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START_BG;
        }

        // ------ Scoring -------
        for (int b = 0; b < randGN; b++) {
          if (isCollide(cs.unit.core, goals[b], cs.size, cs.size - 6)) {
            score++;
          }
        }
        
        // losing
        
        for (int b = 0; b < randON; b++) {
          if (isCollide(cs.unit.core, obs[b], cs.size, cs.size - 6)) {
            state = LOSE_BG;
          }
        }
        

        // ------ Movement ------
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
          // Erase previous Unit
          drawUnit(ps, BLACK, BLACK, BLACK);
          //
          cs.unit.core.col -= 8;
          initUnit(&cs, cs.unit.core.row, cs.unit.core.col, colors[colorIndex][0], colors[colorIndex][1], colors[colorIndex][2]);
          drawUnit(cs, colors[colorIndex][0], colors[colorIndex][1], colors[colorIndex][2]);
        }
        if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
          // Erase previous Unit
          drawUnit(ps, BLACK, BLACK, BLACK);
          //
          cs.unit.core.col += 8;
          initUnit(&cs, cs.unit.core.row, cs.unit.core.col, colors[colorIndex][0], colors[colorIndex][1], colors[colorIndex][2]);
          drawUnit(cs, colors[colorIndex][0], colors[colorIndex][1], colors[colorIndex][2]);
        }
        if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
          // Erase previous Unit
          drawUnit(ps, BLACK, BLACK, BLACK);
          //
          cs.unit.core.row -= 8;
          initUnit(&cs, cs.unit.core.row, cs.unit.core.col, colors[colorIndex][0], colors[colorIndex][1], colors[colorIndex][2]);
          drawUnit(cs, colors[colorIndex][0], colors[colorIndex][1], colors[colorIndex][2]);
        }
        if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
          // Erase previous Unit
          drawUnit(ps, BLACK, BLACK, BLACK);
          //
          cs.unit.core.row += 8;
          initUnit(&cs, cs.unit.core.row, cs.unit.core.col, colors[colorIndex][0], colors[colorIndex][1], colors[colorIndex][2]);
          drawUnit(cs, colors[colorIndex][0], colors[colorIndex][1], colors[colorIndex][2]);
        }        
        if (randGN == score) {
          state = WIN_BG;
        } 
        // state = ?
        break;
      
      case WIN_BG:
        drawImageDMA(0,0, WINBG_WIDTH, WINBG_HEIGHT, winbg);
        state = WON;
        break;
      
      case WON:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, win, BLACK);
          state = START_BG;
        } else {
          // Blinking Text
          delay(7);
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, win, CYAN);
          delay(7);
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, win, CYAN_1);
          delay(7);
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, win, BLACK);
          delay(7);
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, win, CYAN_1);
        }
        // state = ?
        break;
      
      case LOSE_BG:
        drawImageDMA(0,0, LOSEBG_WIDTH, LOSEBG_HEIGHT, losebg);
        state = LOST;
        break;
      
      case LOST:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          // Erase 
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, lose, BLACK);
          state = START_BG;
          break;
        } else {
          // Blinking Text
          delay(7);
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, lose, WHITE_GRAY);
          delay(7);
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, lose, M_GRAY);
          delay(7);
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, lose, BLACK);
          delay(7);
          drawCenteredString((HEIGHT*3)/4, WIDTH/2, 0,0, lose, M_GRAY);
        }
        // state = ?

        break;
    }
    previousButtons = currentButtons;  // Store the current state of the buttons
  }

  UNUSED(previousButtons);  // You can remove this once previousButtons is used

  return 0;
}
